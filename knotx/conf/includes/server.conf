# Configuraiton of HTTP server
serverOptions {
  # Knot.x server HTTP port
  port = ${global.serverPort}

  # If you want a server to serve SSL connections you can configure it here
  #
  # Enable SSL
  # ssl = true
  #
  # Path on the server the keystore.jks file is located
  # keyStoreOptions.path =
  #
  # Keystore password
  # keyStoreOptions.password =
}

# Open API Spec file location
apiDefinitionFile = "/server-api.yaml"

# List of HTTP operations defined in Open API Spec.
operations = [
  {
    id = templating
    handlers = [
#      {
#        # CSRF protection related global configuration
#        name = csrfHandler
#        config {
#          # A CSRF cookie name. Default is XSRF-TOKEN
#          # cookieName =
#
#          # CSRF Cookie path. Default is /
#          # cookiePath =
#
#          # Expected CSRF header name. Default is X-XSRF-TOKEN
#          #
#          # headerName =
#
#          # A secret used to initialize CSRF value generation.
#          # If not set a randomly generated 20 character long value will be used
#          #
#          # secret =
#
#          # THe CSRF token expiration time in milliseconds. Default is 30 minutes (1800000)
#          #
#          # timeout =
#        }
#      }
      {
        name = repositoryHandler
        config.proxyAddress = ${global.repositories.httpRepo.address}
        config.doProcessing = true
        config.allowedResponseHeaders = ${config.server.options.config.allowedResponseHeaders}
      }
      {
        # Here you can define set of routing rules for Knot processing.
        name = templatingHandler
        config.routing {
          address = ${global.bridge.address}
          onTransition.next {
            address = ${global.hbs.address}
          }
          #  # Event bus address of the first Knot that should process the request and template got from the repository
          #  address = my.eventbus.address or ${global.address.knot.something}
          #
          #  # Define a transition to next Knot in the processing chain.
          #  onTransition {
          #    # Previous Knot might generate multiple transition signals. Here you can define
          #    # what will happen on this transition. By default all core Knots generates 'next' transition
          #    # after successfull processing.
          #    #
          #    next {
          #      # Define event bus address of Knot that should process the payload if transition will occur
          #      # address =
          #      #
          #      # Define transition to next Knot if required
          #      # onTransition {}
          #    }
          #  }
        }
        # config.deliveryOptions =
      }
      {
        name = splitterHandler
        config.proxyAddress = knotx.core.splitter
      }
      {
        name = assemblerHandler
        config.proxyAddress = knotx.core.assembler
        config.allowedResponseHeaders = ${config.server.options.config.allowedResponseHeaders}
      },
      # Statically defined HTTP response header returned to the client in every HTTP response
      {
        name = headerHandler
        config.name = X-Server
        config.value = Knot.x
      }

    ]
  }
]

# List of HTTP response headers Knot.x can return to the client for specific operation
allowedResponseHeaders = [
  Access-Control-Allow-Origin
  Allow
  Cache-Control
  Content-Disposition
  Content-Encoding
  Content-Language
  Content-Location
  Content-MD5
  Content-Range
  Content-Type
  Content-Length
  Content-Security-Policy
  Date
  Edge-Control
  ETag
  Expires
  Last-Modified
  Location
  Pragma
  Proxy-Authenticate
  Server
  Set-Cookie
  Status
  Surrogate-Control
  Vary
  Via
  X-Frame-Options
  X-XSS-Protection
  X-Content-Type-Options
  X-UA-Compatible
  X-Request-ID
  X-Server
]


customResponseHeader {
  name = X-Server
  value = Knot.x
}

# Vert.x event bus delivery options used when communicating with other verticles
# see http://vertx.io/docs/vertx-core/dataobjects.html#DeliveryOptions for the details what can be configured
#
# deliveryOptions {}

# Configuraiton of the HTTP Server access log (templating and gatway modes shares the same access log)
accessLog {
  enabled = true # Enable/Disable access log

  # Whether to log after request arrives (true), or after sending response (false). Default is false
  # immediate =

  # Access log format. Default is DEFAULT
  # Available formats: DEFAULT, SHORT, TINY
  # format =
}

# Enable/Disable stack traces on the error pages. Disable it on production
displayExceptionDetails = true

# Limit of uploaded file size in bytes. Default is -1 (unlimited).
# fileUploadLimit =

# Folder where uploaded files will be stored. Default is file-uploads folder in current working directory.
# fileUploadDirectory =

####### Server backpressure section ########

# Enable/Disable request dropping feature (backpressure). Default is disabled
dropRequests = false

# If dropRequest is enabled, a dropped requests will got HTTP response with a status code defined here. Default is 429 (Too many requests)
# dropRequestResponseCode =

# Defines a backpressure capacity buffer used when dropRequests is enabled. Default is 1000 slots
# backpressureBufferCapacity =

# A strategy how the requests are dropped (if the backpressure buffer is full). Default is DROP_LATEST.
# Available values: ERROR (terminate a sequence), DROP_LATEST, DROP_OLDEST
# backpressureStrategy =
